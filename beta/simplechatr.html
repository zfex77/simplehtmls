<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SimpleChat</title>
  <link rel="icon" href="https://github.com/zfex77/simplehtmls/blob/main/src/logo3.png?raw=true" type="image/x-icon" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" />
  <script src="https://cdn.pubnub.com/sdk/javascript/pubnub.4.29.9.min.js"></script>
  <style>
    :root{
      --bg:#0c101a;
      --panel:#ffffff;
      --muted:#6b7280;
      --text:#0b0f17;
      --me:#0a84ff;         /* iMessage blue for me */
      --other:#e5e5ea;      /* iMessage gray for others */
      --otherText:#111;     /* dark text on gray bubble (light theme) */
      --shadow:0 8px 24px rgba(0,0,0,.08);
      --inputBorder: rgba(0,0,0,.08);
      --titleColor:#000;
      --channelColor:#000;
    }
    [data-theme="dark"]{
      --bg:#0d1117;
      --panel:#0b0f14;
      --muted:#cfd8e3;      /* lighter muted for contrast */
      --text:#ffffff;       /* ALL text goes white in dark */
      --me:#0a84ff;
      --other:#2a2f39;      /* darker gray bubble */
      --otherText:#ffffff;  /* white text inside gray bubble (dark) */
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --inputBorder: rgba(255,255,255,.18);
      --titleColor:#fff;  
      --channelColor:#fff;
    }

    html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,"SF Pro Text",Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text);}
    .app{display:grid;grid-template-columns:280px 1fr;gap:16px;height:100vh;padding:16px;box-sizing:border-box;}

    .sidebar{background:var(--panel);border-radius:22px;padding:14px;box-shadow:var(--shadow);display:flex;flex-direction:column;min-width:0}
    .brand{display:flex;align-items:center;gap:10px;padding:6px 8px}
    .brand img{width:34px;height:34px;border-radius:9px}
    .brand .title{font-weight:800;letter-spacing:.2px;color:var(--titleColor);} 
    .brand .subtitle{font-size:12px;color:var(--muted)}
    .search{margin:12px 8px}
    .search input{width:100%;border-radius:14px;border:1px solid var(--inputBorder);background:transparent;padding:8px 12px;color:var(--text)}
    .channels{overflow:auto;padding-right:4px}
    .channel{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:10px 12px;border-radius:14px;cursor:pointer;color:var(--text)}
    .channel:hover{background:rgba(0,0,0,.05)}
    [data-theme="dark"] .channel:hover{background:rgba(255,255,255,.06)}
    .channel.active{background:linear-gradient(180deg,rgba(0,0,0,.05),transparent);box-shadow:inset 0 0 0 1px rgba(0,0,0,.06)}
    [data-theme="dark"] .channel.active{background:linear-gradient(180deg,rgba(255,255,255,.08),transparent);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08)}
    .ch-name{font-weight:700;color:var(--channelColor);}
    .chip{font-size:11px;color:var(--muted)}
    .add-area{display:flex;gap:8px;padding:8px}
    .add-area .btn{border-radius:12px}

    .main{background:var(--panel);border-radius:22px;box-shadow:var(--shadow);display:grid;grid-template-rows:auto 1fr auto;overflow:hidden;min-width:0}

    .header{display:flex;align-items:center;justify-content:space-between;padding:14px 18px;border-bottom:1px solid rgba(0,0,0,.06)}
    .hdr-title{font-weight:800;color:var(--channelColor);}
    .hdr-sub{font-size:12px;color:var(--muted)}
    .switch{display:flex;align-items:center;gap:8px;cursor:pointer;user-select:none}
    .switch input{display:none}
    .thumb{width:44px;height:24px;border-radius:999px;background:rgba(0,0,0,.1);position:relative;transition:.2s}
    [data-theme="dark"] .thumb{background:rgba(255,255,255,.2)}
    .dot{position:absolute;top:3px;left:3px;width:18px;height:18px;border-radius:50%;background:var(--panel);transition:transform .2s}
    input:checked + .thumb .dot{transform:translateX(20px)}

    .messages{overflow-y:auto;padding:20px;display:flex;flex-direction:column;gap:12px;background:linear-gradient(180deg,rgba(127,127,127,.06),transparent 160px)}
    .row{display:flex;flex-direction:column;gap:4px;max-width:72%}
    .row.me{margin-left:auto;align-items:flex-end}
    .row.other{align-items:flex-start}
    .uname{font-size:11px;color:var(--muted);margin:0 6px}
    .bubble{border-radius:18px;padding:10px 14px;line-height:1.35;position:relative;animation:slideIn .12s ease;box-shadow:0 2px 8px rgba(0,0,0,.05)}
    .bubble.me{background:var(--me);color:#fff}
    .bubble.other{background:var(--other);color:var(--otherText)}
    .bubble.neutral{background:var(--other);color:var(--otherText)}
    .bubble img{max-width:280px;border-radius:14px;display:block}
    .meta{margin:0 6px;font-size:11px;color:var(--muted)}
    .pending{opacity:.7;filter:grayscale(8%)}
    .failed{outline:2px solid #ff6b6b}
    @keyframes slideIn{from{transform:translateY(4px);opacity:.0}to{transform:translateY(0);opacity:1}}

    .composer{display:flex;gap:8px;padding:14px;border-top:1px solid rgba(0,0,0,.06)}
    .composer input[type="text"]{flex:1;border-radius:20px;padding:12px 14px;border:1px solid var(--inputBorder);background:transparent;color:var(--text)}
    .icon-btn{display:inline-flex;align-items:center;justify-content:center;border:1px solid var(--inputBorder);background:transparent;border-radius:16px;padding:10px 12px;cursor:pointer}
    .icon-btn svg{width:18px;height:18px;display:block}
    .send-btn{background:var(--me);border-color:var(--me)}
    .send-btn svg{fill:#fff}

    .modal-veil{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(2,6,23,.55);z-index:50}
    .modal-card{background:var(--panel);color:var(--text);padding:18px;width:440px;max-width:92vw;border-radius:14px;box-shadow:var(--shadow)}

    .load-more{text-align:center;padding:10px;margin-bottom:10px}
    .load-more button{background:transparent;border:1px solid var(--inputBorder);color:var(--muted);padding:6px 12px;border-radius:12px;cursor:pointer;font-size:12px}
    .load-more button:hover{background:rgba(0,0,0,.05)}
    [data-theme="dark"] .load-more button:hover{background:rgba(255,255,255,.06)}

    @media (max-width:900px){
      .app{grid-template-columns:1fr;grid-template-rows:240px 1fr}
      .sidebar{order:1}
      .main{order:2}
      .row{max-width:88%}
      
      /* Mobile composer fixes */
      .composer{padding:12px;gap:6px}
      .composer input[type="text"]{
        flex:1;
        min-width:0; /* Prevents overflow */
        border-radius:20px;
        padding:10px 12px;
        font-size:16px; /* Prevents zoom on iOS */
        -webkit-appearance:none; /* Remove iOS styling */
        appearance:none;
      }
      .icon-btn{
        padding:8px 10px;
        flex-shrink:0; /* Prevents buttons from shrinking */
      }
      
      /* Better mobile keyboard handling */
      .main{
        position:relative;
        min-height:0;
      }
      .messages{
        padding-bottom:env(keyboard-inset-height, 0px); /* iOS keyboard safe area */
        -webkit-overflow-scrolling:touch; /* Smooth scrolling on iOS */
      }
    }
    
    /* iOS specific fixes */
    @supports (-webkit-touch-callout: none) {
      .composer input[type="text"]{
        font-size:16px !important; /* Prevents zoom on iOS */
        -webkit-appearance:none;
        -webkit-border-radius:20px;
      }
    }
  </style>
</head>
<body>
  <div class="app" id="app" data-theme="light">
    <div class="sidebar">
      <div class="brand">
        <img src="https://github.com/zfex77/simplehtmls/blob/main/src/logo3.png?raw=true" alt="logo" />
        <div>
          <div class="title">SimpleChat</div>
          <div class="subtitle">by zfex77</div>
        </div>
      </div>
      <div class="add-area">
        <div style="display:flex;gap:8px;width:100%">
          <select id="channel-dropdown" class="form-control" style="flex:1;border-radius:12px;border:1px solid var(--inputBorder);background:var(--panel);color:var(--text)">
            <option value="">Select Channel</option>
          </select>
          <button id="new-channel" class="btn btn-sm btn-primary" style="width:36px;padding:4px">+</button>
          <button id="share-channel" class="btn btn-sm btn-outline-secondary" style="width:36px;padding:4px" title="Share Channel">ðŸ“¤</button>
        </div>
      </div>
    </div>

    <div class="main">
      <div class="header">
        <div>
          <div class="hdr-title" id="header-title">#simple-chat-channel</div>
          <div class="hdr-sub" id="header-sub">Public</div>
        </div>
        <div style="display:flex;align-items:center;gap:14px">
          <div class="hdr-sub">Signed in as <strong id="signed-name">(guest)</strong> Â· <span id="change-name" style="cursor:pointer; text-decoration: underline;">change</span></div>
          <label class="switch" title="Light / Dark">
            <input id="theme-toggle" type="checkbox" />
            <div class="thumb"><div class="dot"></div></div>
          </label>
        </div>
      </div>

      <div class="messages" id="messages">
        <div class="load-more" id="load-more" style="display:none">
          <button onclick="loadMoreHistory()">Load older messages</button>
        </div>
      </div>

      <div class="composer">
        <input id="input" type="text" placeholder="Type a message..." />
        <button id="send" class="icon-btn send-btn" title="Send" aria-label="Send">
          <!-- arrow icon -->
          <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M2 21l20-9L2 3v7l14 2-14 2v7z"/></svg>
        </button>
      </div>
    </div>
  </div>

  <!-- Channel Name Modal -->
  <div id="channel-modal" class="modal-veil">
    <div class="modal-card">
      <h5 style="color:var(--titleColor)">Create New Channel</h5>
      <p style="color:var(--muted);margin-bottom:10px">Choose a name for your channel.</p>
      <input id="channel-input" class="form-control" placeholder="Enter channel name..." style="font-size:16px;background:var(--panel);color:var(--text);border:1px solid var(--inputBorder)" />
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="channel-cancel" class="btn btn-outline-secondary">Cancel</button>
        <button id="channel-save" class="btn btn-primary">Create</button>
      </div>
    </div>
  </div>
  <!-- Username Modal -->
  <div id="name-modal" class="modal-veil">
    <div class="modal-card">
      <h5 style="color:var(--titleColor)">Set your display name</h5>
      <p style="color:var(--muted);margin-bottom:10px">This is how people will see you.</p>
      <input id="name-input" class="form-control" placeholder="Type a name..." style="font-size:16px;background:var(--panel);color:var(--text);border:1px solid var(--inputBorder)" />
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="name-cancel" class="btn btn-outline-secondary">Cancel</button>
        <button id="name-save" class="btn btn-primary">Save</button>
      </div>
    </div>
  </div>

  <script>
    /* ===== CONFIG ===== */
    const publishKey   = 'pub-c-681d632c-989f-4a2d-9076-e70e1ea2c214';
    const subscribeKey = 'sub-c-1e31862d-744e-4817-a27c-1d0a6b73080a';
    const DEFAULT_CHANNEL = 'scc';

    /* ===== STORAGE KEYS ===== */
    const LS_UUID = 'sc-uuid';
    const LS_NAME = 'sc-name';
    const LS_THEME = 'sc-theme';
    const LS_CHANNELS = 'sc-channels';
    const LS_HISTORY_PREFIX = 'sc-history:'; // per-channel
    const LS_OLDEST_TOKEN_PREFIX = 'sc-oldest:'; // track oldest loaded timetoken per channel
    const UA_UPLOAD = 'SimpleChat/1.0 (0x0.st client)';

    /* ===== STABLE UUID ===== */
    let myUUID = localStorage.getItem(LS_UUID);
    if (!myUUID) { myUUID = 'u_' + Math.random().toString(36).slice(2, 10); localStorage.setItem(LS_UUID, myUUID); }

    const pubnub = new PubNub({ publishKey, subscribeKey, uuid: myUUID });

    /* ===== ELEMENTS ===== */
    const app = document.getElementById('app');
    const channelDropdown = document.getElementById('channel-dropdown');
    const messages = document.getElementById('messages');
    const loadMoreBtn = document.getElementById('load-more');
    const input = document.getElementById('input');
    const sendBtn = document.getElementById('send');
    const attachBtn = document.getElementById('attach');
    const fileInput = document.getElementById('file');
    const hdrTitle = document.getElementById('header-title');
    const hdrSub = document.getElementById('header-sub');
    const signedName = document.getElementById('signed-name');
    const changeName = document.getElementById('change-name');
    const modal = document.getElementById('name-modal');
    const nameInput = document.getElementById('name-input');
    const nameSave = document.getElementById('name-save');
    const nameCancel = document.getElementById('name-cancel');
    const channelModal = document.getElementById('channel-modal');
    const channelInput = document.getElementById('channel-input');
    const channelSave = document.getElementById('channel-save');
    const channelCancel = document.getElementById('channel-cancel');
    const shareBtn = document.getElementById('share-channel');
    const themeToggle = document.getElementById('theme-toggle');
    const newChannelBtn = document.getElementById('new-channel');

    /* ===== STATE ===== */
    let currentChannel = DEFAULT_CHANNEL;
    let displayName = localStorage.getItem(LS_NAME) || 'Me';
    let lastSendAt = 0;
    const sentMids = new Set();
    let isLoadingHistory = false;

    function lsHistoryKey(ch){ return LS_HISTORY_PREFIX + ch; }
    function lsOldestTokenKey(ch){ return LS_OLDEST_TOKEN_PREFIX + ch; }
    function loadLocalHistory(ch){ try { return JSON.parse(localStorage.getItem(lsHistoryKey(ch)) || '[]'); } catch(e){ return []; } }
    function saveLocalHistory(ch, arr){ localStorage.setItem(lsHistoryKey(ch), JSON.stringify(arr.slice(-1000))); }
    function pushLocal(ch, msg){ const h = loadLocalHistory(ch); h.push(msg); saveLocalHistory(ch, h); }
    function getOldestToken(ch){ return localStorage.getItem(lsOldestTokenKey(ch)); }
    function setOldestToken(ch, token){ localStorage.setItem(lsOldestTokenKey(ch), token); }

    /* ===== THEME ===== */
    function initTheme(){
      const saved = localStorage.getItem(LS_THEME);
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const dark = saved ? (saved === 'dark') : prefersDark;
      app.setAttribute('data-theme', dark ? 'dark' : 'light');
      themeToggle.checked = dark;
    }
    themeToggle.addEventListener('change', ()=>{
      const dark = themeToggle.checked;
      app.setAttribute('data-theme', dark ? 'dark' : 'light');
      localStorage.setItem(LS_THEME, dark ? 'dark' : 'light');
    });

    /* ===== CHANNELS ===== */
    function getChannels(){ try { return JSON.parse(localStorage.getItem(LS_CHANNELS) || '[]'); } catch(e){ return []; } }
    function setChannels(list){ localStorage.setItem(LS_CHANNELS, JSON.stringify(list)); }
    function ensureDefaultChannel(list){ if(!list.includes(DEFAULT_CHANNEL)) list.push(DEFAULT_CHANNEL); return list; }

    function drawChannels(){
      channelDropdown.innerHTML = '<option value="">Select Channel</option>';
      const all = ensureDefaultChannel(getChannels());
      all.forEach(c => {
        const option = document.createElement('option');
        option.value = c;
        option.textContent = '#' + c;
        if(c === currentChannel) option.selected = true;
        channelDropdown.appendChild(option);
      });
    }

    function addChannel(name){
      const list = getChannels();
      if(!list.includes(name)){ list.unshift(name); setChannels(list); }
      drawChannels();
    }

    function switchChannel(name){
      if(currentChannel === name || !name) return;
      currentChannel = name;
      hdrTitle.textContent = '#' + name; hdrSub.textContent = (name===DEFAULT_CHANNEL?'Public':'Custom');
      try{ pubnub.unsubscribeAll(); }catch(e){}
      pubnub.subscribe({ channels: [name] });
      renderHistory(name);
      const url = new URL(window.location.href); url.searchParams.set('channel', name); history.replaceState({}, '', url);
      drawChannels();
    }

    channelDropdown.addEventListener('change', (e) => {
      const selectedChannel = e.target.value;
      if(selectedChannel) switchChannel(selectedChannel);
    });
    newChannelBtn.addEventListener('click', ()=>{
      openChannelModal();
    });

    /* ===== CHANNEL CREATION MODAL ===== */
    function openChannelModal(){ 
      channelModal.style.display = 'flex'; 
      channelInput.value = ''; 
      channelInput.focus(); 
    }
    function closeChannelModal(){ 
      channelModal.style.display = 'none'; 
    }
    
    channelCancel.addEventListener('click', closeChannelModal);
    channelSave.addEventListener('click', ()=>{
      const name = channelInput.value.trim().toLowerCase().replace(/[^a-z0-9-_]/g, '');
      if(!name) return alert('Enter a valid channel name (letters, numbers, - and _ only)');
      addChannel(name); 
      switchChannel(name);
      closeChannelModal();
      alert('Switched to #' + name + '. Share the URL to invite others.');
    });
    
    // Enter key support for channel modal
    channelInput.addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){ e.preventDefault(); channelSave.click(); }
    });

    /* ===== SHARE FUNCTIONALITY ===== */
    shareBtn.addEventListener('click', ()=>{
      const url = window.location.href;
      if(navigator.share){
        navigator.share({
          title: 'SimpleChat - #' + currentChannel,
          text: 'Join me on SimpleChat!',
          url: url
        }).catch(err => console.log('Share failed:', err));
      } else {
        // Fallback: copy to clipboard
        navigator.clipboard.writeText(url).then(()=>{
          alert('Channel link copied to clipboard!');
        }).catch(()=>{
          // Ultimate fallback: show URL
          prompt('Share this link:', url);
        });
      }
    });

    /* ===== USERNAME ===== */
    function openNameModal(){ modal.style.display = 'flex'; nameInput.value = displayName; nameInput.focus(); }
    function closeNameModal(){ modal.style.display = 'none'; }
    function setName(v){ displayName = v || 'Me'; localStorage.setItem(LS_NAME, displayName); signedName.textContent = displayName; }
    changeName.addEventListener('click', openNameModal);
    nameCancel.addEventListener('click', closeNameModal);
    nameSave.addEventListener('click', ()=>{
      const v = nameInput.value.trim();
      if(!v) return alert('Enter a name'); setName(v); closeNameModal();
    });
    
    // Enter key support for name modal
    nameInput.addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){ e.preventDefault(); nameSave.click(); }
    });

    /* ===== RENDER ===== */
    function fmtTime(ts){ 
      try{ 
        const d = new Date(ts || Date.now()); 
        return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
      }catch(_){return '';} 
    }

    function renderOne(msg, prepend=false){
      const mine = (msg.uuid === myUUID);
      const whoClass = mine ? 'me' : 'other';

      const wrap = document.createElement('div');
      wrap.className = `row ${whoClass}`;
      wrap.setAttribute('data-timetoken', msg.timetoken || '');

      // Username above bubble
      const uname = document.createElement('div');
      uname.className = 'uname';
      uname.textContent = (msg.username || (mine?'You':'User'));
      wrap.appendChild(uname);

      const bubble = document.createElement('div');
      bubble.className = `bubble ${mine ? 'me':'other'}`;

      if(msg.type === 'image' && msg.url){
        bubble.innerHTML = `<img src="${msg.url}" alt="image" />`;
      } else if(msg.type === 'image' && msg.data){
        bubble.innerHTML = `<img src="${msg.data}" alt="image" />`;
      } else {
        const text = msg.text || '';
        
        // Check for image URLs and embed them
        const imageUrlRegex = /https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp|bmp|svg)(\?[^\s]*)?/gi;
        if(imageUrlRegex.test(text)){
          const imageUrl = text.match(imageUrlRegex)[0];
          bubble.innerHTML = `<img src="${imageUrl}" alt="image" style="max-width:280px;border-radius:14px;display:block" />`;
        } else {
          bubble.textContent = text;
        }
      }

      if(msg._pending) bubble.classList.add('pending');
      if(msg.failed) bubble.classList.add('failed');

      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.textContent = fmtTime(msg.ts || msg.timetoken);

      wrap.appendChild(bubble);
      wrap.appendChild(meta);
      
      if(prepend && messages.children.length > 0){
        // Insert after load-more button if it exists
        const firstMsg = messages.querySelector('.row');
        if(firstMsg){
          messages.insertBefore(wrap, firstMsg);
        } else {
          messages.appendChild(wrap);
        }
      } else {
        messages.appendChild(wrap);
        messages.scrollTop = messages.scrollHeight;
      }

      return wrap;
    }

    /* ===== HISTORY LOADING ===== */
    async function loadMoreHistory(){
      if(isLoadingHistory) return;
      isLoadingHistory = true;
      
      const btn = loadMoreBtn.querySelector('button');
      const originalText = btn.textContent;
      btn.textContent = 'Loading...';
      btn.disabled = true;

      try {
        const oldestToken = getOldestToken(currentChannel);
        if(!oldestToken){
          loadMoreBtn.style.display = 'none';
          return;
        }

        const result = await pubnub.fetchMessages({
          channels: [currentChannel],
          count: 100, // Max for single channel
          end: oldestToken
        });

        const channelData = result.channels[currentChannel] || [];
        if(channelData.length === 0){
          loadMoreBtn.style.display = 'none';
          btn.textContent = 'No more messages';
          return;
        }

        // Convert to our message format and prepend
        const oldScrollHeight = messages.scrollHeight;
        
        channelData.forEach(item => {
          const msg = {
            ...item.message,
            timetoken: item.timetoken,
            ts: item.timetoken ? Math.floor(item.timetoken / 10000) : Date.now()
          };
          renderOne(msg, true); // prepend=true
        });

        // Update oldest token for next load
        const oldestMessage = channelData[channelData.length - 1];
        if(oldestMessage){
          setOldestToken(currentChannel, oldestMessage.timetoken);
        }

        // Maintain scroll position
        const newScrollHeight = messages.scrollHeight;
        messages.scrollTop = newScrollHeight - oldScrollHeight;

        // Hide button if we got less than requested (probably no more)
        if(channelData.length < 100){
          loadMoreBtn.style.display = 'none';
        }

      } catch(err){
        console.warn('Failed to load more history:', err);
        btn.textContent = 'Failed to load';
      } finally {
        isLoadingHistory = false;
        btn.textContent = originalText;
        btn.disabled = false;
      }
    }

    // Make loadMoreHistory global so the onclick can find it
    window.loadMoreHistory = loadMoreHistory;

    function renderHistory(ch){
      messages.innerHTML = '';
      
      // Add load more button
      const loadMore = document.createElement('div');
      loadMore.className = 'load-more';
      loadMore.id = 'load-more';
      loadMore.style.display = 'block';
      loadMore.innerHTML = '<button onclick="loadMoreHistory()">Load older messages</button>';
      messages.appendChild(loadMore);

      // Load recent messages first
      pubnub.fetchMessages({ 
        channels: [ch], 
        count: 100 // Increased from 50 to 100 (max for single channel)
      }).then(res => {
        const list = (res.channels && res.channels[ch]) || [];
        
        if(list.length === 0){
          loadMore.style.display = 'none';
          return;
        }

        // Convert PubNub format to our format
        const serverMsgs = list.map(item => ({
          ...(item.message || {}),
          timetoken: item.timetoken,
          ts: item.timetoken ? Math.floor(item.timetoken / 10000) : Date.now()
        }));

        // Store oldest token for pagination
        if(serverMsgs.length > 0){
          const oldestMsg = serverMsgs[serverMsgs.length - 1];
          setOldestToken(ch, oldestMsg.timetoken);
        }

        // Render messages
        serverMsgs.forEach(m => renderOne(m));

        // Hide load more button if we got less than max (probably no more history)
        if(list.length < 100){
          loadMore.style.display = 'none';
        }

      }).catch(err => {
        console.warn('History fetch failed:', err);
        loadMore.style.display = 'none';
      });
    }

    /* ===== SEND TEXT (dedup + cooldown) ===== */
    let lastSentDomPending = null;
    function sendText(text){
      if(!text) return;
      
      // Check for delete command
      if(text.startsWith('!delete evonoxcekunawa16')){
        // Create new "clean" channel name
        const timestamp = Date.now();
        const newChannelName = currentChannel + '-clean-' + timestamp;
        
        // Send migration message to all current users
        const migrateMsg = { 
          type: 'channel_migrate', 
          newChannel: newChannelName,
          username: displayName, 
          uuid: myUUID, 
          ts: Date.now() 
        };
        
        pubnub.publish({ channel: currentChannel, message: migrateMsg }).then(() => {
          // Switch ourselves to the new channel
          addChannel(newChannelName);
          switchChannel(newChannelName);
        });
        return;
      }
      
      const now = Date.now();
      if(now - lastSendAt < 250) return; // avoid double send
      lastSendAt = now;

      const mid = 'm_' + Math.random().toString(36).slice(2,10);
      const msg = { mid, text, username: displayName, uuid: myUUID, ts: now };

      sentMids.add(mid);
      msg._pending = true;
      lastSentDomPending = renderOne(msg);

      pubnub.publish({ channel: currentChannel, message: msg })
        .then(() => markDelivered(mid))
        .catch(() => markFailed(mid));
    }

    function markDelivered(mid){
      if(lastSentDomPending){
        const bub = lastSentDomPending.querySelector('.bubble.pending');
        if(bub) bub.classList.remove('pending');
      }
    }
    function markFailed(mid){
      if(lastSentDomPending){
        const bub = lastSentDomPending.querySelector('.bubble.pending');
        if(bub){ bub.classList.remove('pending'); bub.classList.add('failed'); }
      }
    }

    sendBtn.addEventListener('click', ()=>{
      const t = input.value.trim(); if(!t) return;
      input.value=''; sendText(t);
    });
    input.addEventListener('keydown', (e)=>{
      if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); sendBtn.click(); }
    });

    /* ===== RECEIVING (skip duplicates) ===== */
    pubnub.addListener({
      message: function(ev){
        const msg = ev.message || {};
        
        // Handle channel migration (delete all)
        if(msg.type === 'channel_migrate'){
          // Switch to the new clean channel
          addChannel(msg.newChannel);
          switchChannel(msg.newChannel);
          
          // Show migration notification
          setTimeout(() => {
            const migrateNotice = document.createElement('div');
            migrateNotice.style.cssText = 'text-align:center;color:var(--muted);font-size:12px;padding:10px;';
            migrateNotice.textContent = `${msg.username || 'Someone'} cleared the chat - moved to clean channel`;
            messages.appendChild(migrateNotice);
          }, 500);
          return;
        }
        
        if(msg.mid && sentMids.has(msg.mid)){
          sentMids.delete(msg.mid);
          // Update delivered & DOM
          const pendingBubble = messages.querySelector('.row.me .bubble.pending');
          if(pendingBubble) pendingBubble.classList.remove('pending');
          // If hosted URL arrived for an image, ensure DOM shows it
          if(msg.type==='image' && msg.url){
            const lastMe = messages.querySelector('.row.me:last-child .bubble');
            if(lastMe) lastMe.innerHTML = `<img src="${msg.url}" alt="image" />`;
          }
          return;
        }
        
        // Check for duplicates by timetoken to avoid showing same message twice
        const existingMsg = messages.querySelector(`[data-timetoken="${ev.timetoken}"]`);
        if(existingMsg) return;
        
        // Add timetoken and timestamp to message
        msg.timetoken = ev.timetoken;
        msg.ts = ev.timetoken ? Math.floor(ev.timetoken / 10000) : Date.now();
        
        // Store & render incoming
        renderOne(msg);
      }
    });

    /* ===== INIT ===== */
    function boot(){
      initTheme();
      setName(displayName);
      const params = new URLSearchParams(location.search);
      const fromURL = params.get('channel');
      if(fromURL){ currentChannel = fromURL; }
      hdrTitle.textContent = '#' + currentChannel;
      addChannel(DEFAULT_CHANNEL); addChannel(currentChannel);
      drawChannels();
      pubnub.subscribe({ channels: [currentChannel] });
      renderHistory(currentChannel);
    }
    boot();
  </script>
</body>
</html>
